zookeeper 

netty 

jsch 
dropwizard jetty hk2 IOC容器 

spring

hadoop大家源码

DI—Dependency Injection，即“依赖注入”：
Ioc—Inversion of Control，即“控制反转”

go 
docker(moby) beego 调度借鉴jdk timmer scheduleThreadPoold 队列多线程，由于协程开销（原理出入栈，开销特别小），队列长度事1.

docker一定要，k8s还是其他paas技术，重启是很正常的，对于一个真正的微服务，就应该是一个很好的支持重启后业务重建，无状态的服务。
考虑高可用或者容灾，也就是重启能兼容上一次的执行结果，举个例子：如果备份分发代理分发了一部分另一部分还没分发，这个时候重启，就要接着分发，同时
已经分发过的不下发备份指令，但是需要重新创建监听继续监听代理执行结果。
任务状态，子任务状态持久化，并且及时记录。

协程

python 

财务分析小程序
协程 生成器 pandas numpy matplotlib

angularjs2

drools 

流处理引擎

读书：管理，产品等

能力
设计角度，解决问题的角度：技术敏感，略懂，上手快，设计合理
具体实现摸个模块实现角度：安责任划分，越单一越好。


类加载
虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配



高效：
从系统设计的角度
1.从系统设计上  模块间有依赖的尽量解耦 瓶颈性能问题：
1）一般由于资源限制，例如网络带宽，或者cpu（集中处理模块由于数据的峰值到来，无法及时响应导致的阻塞）等，
解耦，一定要有一个消息模块，或者缓冲队列来解耦处理。 中心为什么是中心（例如多中心，业务分组或者zookeeper集群做中心），处理下移等  。

还有些有限资源比如数据库连接，由于数据库本身性能问题，需要限制连接个数（不然数据库应该也是一样缓存排队，或者切换），
解决：线程池，为了性能和更好的管控（避免泄露）。在很多场景下，要求下响应事件，就可以在初始化的时候把，压力（构建连接）很耗时处理掉，在运行过程中就会加快影响速度。
比如：淘宝等会再初始化做很多工作，不在乎初始化事件只在乎用户体验响应时间。
另外的，线程池初始化的过程提高效率或进行，一般设计的时候会使用futureTask+ConcurrentHashMap的来做线程池。

从具体模块设计的角度
2)线程泛滥或者任务泛滥的，线程切换很耗时的，解决a:2*cpu，通常也不会去限制业务代码处理这块（检测，等待，唤醒），
。或者设计一个
中间模块来专项处理，管控线程数+任务队列。 b.还有一大部分是（我们的开发人员多线程开发不足导致的）锁写的有问题，

1.经常的现象对static方法枷锁，很严重的。
2.sychronize 直接对方法枷锁，看着没事，数据量一大可能出问题，大部分情况下没必要功能枷锁，最简单的声明多个object syschronize对object分段枷锁，
实际上hashmap hashtable和concurrenthashmap、

如果对volitale很熟，能用当然会更高效。但是还是建议使用reentrantlock和synchronized去做，volitale的内存语义比较复杂，我立即就是所有共享变量都要valitale，
平时用的最多的还是cas无锁算法的支持。

 c:协程解决，

2.代码层面，首先需要jstack，jconsole分析系统，FULL GC过多（一般情况下是由于文件或者网络数据等就是连续存储的大对象过多导致的），minor GC过多，
碎片对象来回释放到时的，heap栈太深，statck内存各个块数据  

有的时候可能就需要大量的大块数据，就需要调整jvm参数。



问题：
1，double check 问题 volatile ，final
2.重载string jdk java开头的包中的类一般来说是无法重载的，双亲委派模式。但是也可以通过jvm启动参数 xbootstrappath



zookeeper 

netty 

jsch 
dropwizard jetty hk2 IOC容器 

spring

hadoop大家源码

DI—Dependency Injection，即“依赖注入”：
Ioc—Inversion of Control，即“控制反转”

go 
docker(moby) beego 调度借鉴jdk timmer scheduleThreadPoold 队列多线程，由于协程开销（原理出入栈，开销特别小），队列长度事1.

docker一定要，k8s还是其他paas技术，重启是很正常的，对于一个真正的微服务，就应该是一个很好的支持重启后业务重建，无状态的服务。
考虑高可用或者容灾，也就是重启能兼容上一次的执行结果，举个例子：如果备份分发代理分发了一部分另一部分还没分发，这个时候重启，就要接着分发，同时
已经分发过的不下发备份指令，但是需要重新创建监听继续监听代理执行结果。
任务状态，子任务状态持久化，并且及时记录。

协程

python 

财务分析小程序
协程 生成器 pandas numpy matplotlib

angularjs2

drools 
流处理引擎，规则强大，可订制很复杂的规则来处理流式数据

读书：管理，产品等

能力
设计角度，解决问题的角度：技术敏感，略懂，上手快，设计合理
具体实现摸个模块实现角度：安责任划分，越单一越好。


类加载
虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配



高效：
从系统设计的角度
1.从系统设计上  模块间有依赖的尽量解耦 瓶颈性能问题：
1）一般由于资源限制，例如网络带宽，或者cpu（集中处理模块由于数据的峰值到来，无法及时响应导致的阻塞）等，
解耦，一定要有一个消息模块，或者缓冲队列来解耦处理。 中心为什么是中心（例如多中心，业务分组或者zookeeper集群做中心），处理下移等  。

还有些有限资源比如数据库连接，由于数据库本身性能问题，需要限制连接个数（不然数据库应该也是一样缓存排队，或者切换），
解决：线程池，为了性能和更好的管控（避免泄露）。在很多场景下，要求下响应事件，就可以在初始化的时候把，压力（构建连接）很耗时处理掉，在运行过程中就会加快影响速度。
比如：淘宝等会再初始化做很多工作，不在乎初始化事件只在乎用户体验响应时间。
另外的，线程池初始化的过程提高效率或进行，一般设计的时候会使用futureTask+ConcurrentHashMap的来做线程池。

从具体模块设计的角度
2)线程泛滥或者任务泛滥的，线程切换很耗时的，解决a:2*cpu，通常也不会去限制业务代码处理这块（检测，等待，唤醒），
。或者设计一个
中间模块来专项处理，管控线程数+任务队列。 b.还有一大部分是（我们的开发人员多线程开发不足导致的）锁写的有问题，

1.经常的现象对static方法枷锁，很严重的。
2.sychronize 直接对方法枷锁，看着没事，数据量一大可能出问题，大部分情况下没必要功能枷锁，最简单的声明多个object syschronize对object分段枷锁，
实际上hashmap hashtable和concurrenthashmap、

如果对volitale很熟，能用当然会更高效。但是还是建议使用reentrantlock和synchronized去做，volitale的内存语义比较复杂，我立即就是所有共享变量都要valitale，
平时用的最多的还是cas无锁算法的支持。

 c:协程解决，

2.代码层面，首先需要jstack，jconsole分析系统，FULL GC过多（一般情况下是由于文件或者网络数据等就是连续存储的大对象过多导致的），minor GC过多，
碎片对象来回释放到时的，heap栈太深，statck内存各个块数据  

有的时候可能就需要大量的大块数据，就需要调整jvm参数。



问题：
1，double check 问题 volatile ，final
2.重载string jdk java开头的包中的类一般来说是无法重载的，双亲委派模式。但是也可以通过jvm启动参数 xbootstrappath



